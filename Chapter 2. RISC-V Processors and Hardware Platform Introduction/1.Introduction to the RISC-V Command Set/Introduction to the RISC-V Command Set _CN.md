# RISC-V指令集简介

RISC-V指令集由美国加州伯克利分校的的Krste Asanovic教授和Yunsup Lee等开发人员于2010年发明。RISC-V指令集是一种精简指令集。

指令集通常分为俩种：复杂指令集与精简指令集。复杂指令集的特点是单条指令即可完成一项复杂的事情，精简指令集在此基础上将一项复杂的事项细分为几项指令去完成。使用复杂指令集将增加CPU设计的复杂度，在一定程度上减小代码的容量与复杂度，精简指令集完成同样的事项需要若干条指令去实现，这样会增加代码的容量甚至是代码的复杂度。但从发展趋势来看，精简指令集是当前的主要发展方向。

RISC-V指令集独特之处在于其是一个模块化的指令集，RV32I指令集是必须实现的，仅使用RV32I指令集即可以实现一个完整的软件栈。CPU设计者可以根据实际需求选择需要实现的指令模块。

# RISC-V指令格式

RISC-V有六种基本的指令格式：`R`，`I`，`S`，`B`，`U`，`J`.

- R型指令——用于寄存器与寄存器之间算术运算操作；
- I 型指令——用于寄存器与立即数之间算术运算和读(load)存储器操作；
- S型指令——用于写(store)存储器；
- B型指令——用于条件跳转操作；
- U型指令——用于高20比特位立即数(长立即数)操作；
- J型指令——用于无条件跳转操作。

RISC-V指令只有6种格式，其指令格式具有下述特点：

- 所有的指令长度都是32位，指令的低7位固定为opcode(操作码)，采用该设计简化了指令解码。
- 读写寄存器的标识符均在同一位置，在解码指令之前即可访问寄存器。
- 立即数字段为符号扩展，符号位保持在最高位。

下图是6种指令结构的构成。

![](figures\formats.png)

接下来我们看一下上述指令结构中每个字段的含义：

- opcode：指令的操作码，该字段代表着该指令的类型。
- rd：目的操作寄存器，该字段存放的是目的寄存器的编码，用来存放操作结果。
- funct3：功能码字段，占3bit。
- rs1：第一个源操作数寄存器。
- rs2：第二个源操作数寄存器。
- funct7：功能码字段，占7bit。
- imm：立即数字段。

学习了RISC-V指令的格式后，在接下来我们将分别介绍每种指令。

# RISC-V指令-R型指令

RISC-V指令的最低7bit固定为操作码(opcode)，识别操作码可以识别该指令为是否为R型指令。

根据funct3字段和funct7字段可以得出具体的执行操作。

根据rs1,rs2与rd便可以执行具体的操作。

RV32的R型指令指令如下：

![](figures\RV32I.png)

R型指令使用示例：

1.将寄存器 a1 和 a2 中的值相加，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 + a2
add a0, a1, a2 
```

2.将寄存器 a1 中的值减去寄存器 a2 中的值，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 - a2
sub a0, a1, a2
```

3.将寄存器 a1 中的值左移 a2 位，低位补0，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 << a2
sll a0, a1, a2
```

4.将寄存器 a1 中的值右移 a2 位，高位补0，并将结果存储在寄存器 a0中，示例：

```assembly
//a0 = a1 >> a2
srl a0, a1, a2 
```

5.将寄存器 a1 中的值算术右移 a2 位，高位补原来的符号位，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 >> a2
sra a0, a1, a2
```

6.如果寄存器 a1 中的值小于寄存器 a2 中的值，则将寄存器 a0 置为1，否则置为0，示例：

```assembly
//a1 < a2 ? a0 = 1 : a0 = 0
slt a0, a1, a2
```

7.将寄存器 a1 和 a2 中的值按位异或，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 ^ a2
xor a0, a1, a2
```

8.将寄存器 a1 和 a2 中的值按位或，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 | a2
or  a0, a1, a2
```

9.将寄存器 a1 和 a2 中的值按位与，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 & a2
and a0, a1, a2
```

# RISC-V指令-I型指令

RISC-V指令的最低7bit固定为操作码(opcode)，识别操作码可以识别该指令为是否为I型指令。

根据funct3字段可以得出具体的执行操作。

目的寄存器位宽5bit，在指令的7-11bit。

rs1是第一个源操作数寄存器，位宽5bit，在指令的15-19bit。

imm[11:0]存放12位立即数，在指令的20-31bit。

RV32I的I型指令指令如下：

![](figures\RV32I_I.png)

I型指令使用示例：

1.将寄存器 a1 和立即数 0x5 相加，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 + 0x5
addi a0, a1, 0x5
```

2.将寄存器 a1 中的值减去立即数 0x05，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 - 0x05
subi a0, a1, 0x05
```

3.将寄存器 a1 中的值左移 0x05 位，低位补0，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 << 0x05(低位补0)
slli a0, a1, 0x05
```

4.将寄存器 a1 中的值右移 0x05 位，高位补0，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 >> 0x05(高位补0)
srli a0, a1, 0x05
```

5.寄存器 a1 中的值算术右移 0x05 位，高位补原来的符号位，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 >> 0x05 (算术右移，高位补原来的符号位)
srai a0, a1, 0x05
```

6.如果寄存器 a1 中的值小于立即数 0x05，则将寄存器 a0 置为1，否则置为0，示例：

```assembly
//a1 < 0x05 ? a0 = 1 : a0 = 0
slti a0, a1, 0x05
```

7.将寄存器 a1 和立即数 0x05 中的值按位异或，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 ^ 0x05
xori a0, a1, 0x05
```

8.将寄存器 a1 和立即数 0x05 中的值按位或，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 | 0x05
ori a0, a1, 0x05
```

9.将寄存器 a1 和立即数 0x05 中的值按位与，并将结果存储在寄存器 a0 中，示例：

```assembly
//a0 = a1 & 0x05
andi a0, a1, 0x05
```

访存(load)指令：

![](figures\RV32I_I_load.png)

I型load指令使用示例：

1.将寄存器 x1 的值加上 0 作为地址，从这个地址对应的内存中取出 8 位数值，并将这个值赋给寄存器 x10，示例：

  ```  assembly
lb x10,  0(x1)  
  ```

2.将寄存器 x1 的值加上 0 作为地址，从这个地址对应的内存中取出 16 位数值，并将这个值赋给寄存器 x10，示例：

```assembly
lh x10, 0(x1)
```

3.将寄存器 x1 的值加上 0 作为地址，从这个地址对应的内存中取出 32 位数值，并将这个值赋给寄存器 x10，示例：

```assembly
lw x10, 0(x1)
```

4.将寄存器 x1 的值加上 0 作为地址，从这个地址对应的内存中取出 8 位无符号数值，并将这个值赋给寄存器 x10，示例：

```assembly
lbu x10, 0(x1)
```

5.将寄存器 x1 的值加上 0 作为地址，从这个地址对应的内存中取出 16 位无符号数值，并将这个值赋给寄存器 x10，示例：

```assembly
lhu x10, 0(x1)
```

# RISC-V指令-S型指令

RISC-V指令的最低7bit固定为操作码(opcode)，识别操作码可以识别该指令为是否为S型指令。

根据funct3字段可以得出具体的执行操作。

目的寄存器位宽5bit，在指令的7-11bit。

rs1是第一个源操作数寄存器，位宽5bit，在指令的15-19bit。

rs2是第二个源操作数寄存器，位宽5bit，在指令的25-31bit。

imm[4:0]+imm[11:5]存放12位立即数。

RV32I的S型指令如下：

![](figures\RV32I_S.png)

I型指令使用示例：

1.将寄存器 x1 的值加上 0 作为地址，将寄存器 x10 的值存储到上述地址所对应的内存中（只会将 x10 的值的低 8 位写入），示例：

```assembly
sb x10, 0(x1)
```

2.将寄存器 x1 的值加上 0 作为地址，将寄存器 x10 的值存储到上述地址所对应的内存中（只会将 x10 的值的低 16 位写入），示例：

```assembly
sh x10, 0(x1)
```

3.将寄存器 x1 的值加上 0 作为地址，将寄存器 x10 的值存储到上述地址所对应的内存中（只会将 x10 的值的低 32 位写入），示例：

```assembly
sw x10, 0(x1)
```

# RISC-V指令-B型指令

RISC-V指令的最低7bit固定为操作码(opcode)，识别操作码可以识别该指令为是否为B型指令。

根据funct3字段可以得出具体的执行操作。

rs1是第一个源操作数寄存器，位宽5bit，在指令的15-19bit。

rs2是第二个源操作数寄存器，位宽5bit，在指令的25-31bit。

imm[4:1]+imm[11]+imm[10:5]+imm[12]存放12位立即数。

RV32I的B型指令如下：

![](figures\RV32I_B.png)

B型指令使用示例：

1.如果寄存器 `a1` 的值等于寄存器 `a2` 的值，则跳转到 `Label`，示例：

```assembly
beq a1,a2,Label
```

2.如果寄存器 `a1` 的值不等于寄存器 `a2` 的值，则跳转到 `Label`，示例：

```assembly
bne a1,a2,Label 
```

3.如果寄存器 `a1` 的值小于寄存器 `a2` 的值，则跳转到 `Label`，示例：

```assembly
blt a1,a2,Label
```

4.如果寄存器 `a1` 的值大于寄存器 `a2` 的值，则跳转到 `Label`，示例：

```assembly
bgt a1,a2,Label
```

5.如果寄存器 `a1` 的值大于或等于寄存器 `a2` 的值，则跳转到 `Label`，示例：

```
bge a1,a2,Label
```

6.如果寄存器 `a1` 的值小于或等于寄存器 `a2` 的值，则跳转到 `Label`，示例：

```assembly
ble a1,a2,Label
```

# RISC-V指令-U型指令

RISC-V指令的最低7bit固定为操作码(opcode)，可以通过操作码识别出该指令为U型指令。

目的寄存器位宽5bit，在指令的7-11bit。

imm[31:12]:存放高20位的立即数，在指令的12-31bit。

RV32I的U型指令如下：

![](figures\RV32I_U.png)

U型指令使用示例：

1.获取立即数的高20位，低位补0，立即数范围为：0x00~0xFFFFF，示例：

```assembly
lui  x10, 0x65432
```

# RISC-V指令-J型指令

RISC-V指令的最低7bit固定为操作码(opcode)，可以通过操作码识别出该指令为U型指令。

目的寄存器位宽5bit，在指令的7-11bit。

imm[19:12]+imm[11]+imm[10:1]+imm[20]:存放20位的立即数。

RV32I的J型指令jal如下（下图中的jalr指令属于I型指令，在这里仅用于类比jal指令）：

![](figures\RV32I_J.png)

J型指令使用示例：

1.跳转到标签 `symbol` 指定的位置，并将下一条指令的地址存储到寄存器 `ra`，示例：

```assembly
jal ra, symbol
```

2.跳转到pc + 100 * 2的地址, 并把ra设置成返回地址  pc相对寻址，对应的是位置无关代码，示例：

```assembly
jal ra, 100
```

3.跳转到寄存器 `x10` 的值加上 40（字节）的位置，并将下一条指令的地址存储到寄存器 `ra`，示例：

```assembly
jalr ra, 40(x10)
```

